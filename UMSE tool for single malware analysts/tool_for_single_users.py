#!/usr/bin/env python
# -*- coding: UTF-8 -*-

"""
*  UMSE Antivirus Agent Example
*  Author: David Alvarez Perez <dalvarezperez87[at]gmail[dot]com>
*  Module: UMSE Tool for Single Users
*  Description: This module allows to easily generate UMSE samples.
*
*  Copyright (c) 2019-2020. The UMSE Authors. All Rights Reserved.
*  Redistribution and use in source and binary forms, with or without modification,
*  are permitted provided that the following conditions are met:
*
*  1. Redistributions of source code must retain the above copyright notice, this
*  list of conditions and the following disclaimer.
*
*  2. Redistributions in binary form must reproduce the above copyright notice,
*  this list of conditions and the following disclaimer in the documentation and/or
*  other materials provided with the distribution.
*
*  3. Neither the name of the copyright holder nor the names of its contributors
*  may be used to endorse or promote products derived from this software without
*  specific prior written permission.
*
*  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
*  ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
*  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
*  DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR
*  ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
*  (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
*  LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
*  ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
*  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
*  SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*
"""

import os
import tkinter as tk
from tkinter import filedialog
from tkinter import messagebox
import ctypes
import struct
import umse
from kaitaistruct import KaitaiStream
from io import BytesIO

RSA_PRIVATE_KEY = b'''-----BEGIN RSA PRIVATE KEY-----
MIIEpAIBAAKCAQEAshHVwiJ8qxm34hs9fan7cZYU2nmcELfxLeSPzQ1Zp/T+w0Iu
nWxzbYxMbaVP1kZ6Dxs3XO9mJyjY67wMj86NUvqwIiT4ypEI1Fve2Mjk6d9/0u5K
NvwSQVrGOrYdoWz23I8vrrLaXiMytarQzipoXUZ30j+JO3giF/EqZKgCjusxAcAL
A5LItUKKH7kjjn4quhelrtzwMZ6m925uturPvHy7FKCCihAj6f6DHUTjY3u+6tY1
okrNlT94YwnGmbu9RaHXQLDsIj1JNjs1A6ww0R/NXeLuOS7dm34vBfz4WjPm7BgT
L7fsPD/gzBzSdDT8bEsSCxXC3l+71oRVeOeMwQIDAQABAoIBAQCco9e3iILGOD9r
ZK74xfhr+Kura+J/Sm+cAT0GEcJWXstkk+lRjb8UFKB+qzbJtQFWHIjc9bKUq/f1
llwufHIRFnit8HvyJRbxR0eGx2Gm4XYd5IPgTmj4mJNbvivefm3Boys8sBQrTyci
a3p2gROBSaXJix5687h5+ylhlfF6Ka3WojSRETG8NTacUANYlGxRIFMT4QFMoK/A
bUwPhBF5L+qELevZoSia+vIYbpmcJw3+X+LJeCAYHbvbd8LZIsc5oUaCx6G2Egna
ooyvvF53swsdeaO0KOw0K2DTQ8sMJ8twC92hTPTtfNfHyWwg+EX8d2GEWWvxiQ9y
ToaTKdxJAoGBAN8+jrcopw8ypIeYzJ5sKPpt7NxdD6Eg/rukAqYcyrs75mHivZhA
FTzyLIABSyZmF6QBfH1N/5VbiYV/yqBvikwf0Hx8tvcwOkrbVWa9yC5KR1gRJIFE
JYPWnUdDbLh73kcFj2Y9Usc8XKy2Ay6vWderCfysn85bKlVnGOEd8h4HAoGBAMwy
cCpbTJ+moE50UKgoqoPaidmCT4T79U9immqgbi1B6Bnal2Fw3cVaJ583btzw4iVr
pZPyKWAZ0bYilH7toAmnTZxKZrs4EUroaJoV/6f0x2leu9hHOqO8TRmtovzFey9X
VjtegMpmkp5vhz4jz9Mf6+m8qMWdm54/VAow6cz3AoGAJVShqtEadnkieCY9+TPe
+lmNZSAOsAQDdL8tTje8UujmUnIHAEGfC4z3kgQlW+twgpVZCt8TIReofHFtIbzl
JGuhgl+cfONMrB3XPxH3On5jRb/AGfmaSFyH+lW1BXh5J+kvHIqeoABhAuSAzbq2
zFCmn+EB7BDkmFlgGKzYQtsCgYA/ufoBbg7iwFjFQ02svUxB7CEbTazNfuiXBtnU
Lw9Tdn8eGncmBNhhb/pvmRgzQcYCEa9SFcBN6qDlK7OWTUil2p3BCgM3qI7VBuUm
OXlZDG5zdwo+vDQTx390ZRk5s9P2+VXDH4IoKIzXf00A2qJQbGTuxF8TlVVstKzg
pVVCDwKBgQDOfcmA1tilfF7Sx82kHMNpXdz5JB7803UYDMWDJlHSj0NX96rW03I+
4fzlfx/hqDWScIjTu+bU0sSfj2V55vyOLunQ2YB156avIZeE7IbPWhLhTwspHpiz
GSdCnIchOhCCZ65mM6q84dZvfi6Ayvr/gS6kroZvkVE9FTrfI02z7w==
-----END RSA PRIVATE KEY-----'''

def encrypt_appending_key():
    '''
    @description This function asks the user for a file and generates the corresponding UMSE sample
    but embedding the RSA Private key at the end of the file (into the corresponding UMSE optional field).
    This use case of UMSE is appropriate to trade malware samples easily (without taking care
    about encryption) but in a specific format.
    '''
    root = tk.Tk()
    root.withdraw()
    file_path = filedialog.askopenfilename(title="Generate UMSE file.")

    lib_umse_dll = ctypes.cdll.LoadLibrary("libUmse.dll")
    file_content = None
    with open(file_path, 'rb') as f:
        file_content = f.read()
    file_content_length = ctypes.c_int(len(file_content))
    umseSize = ctypes.c_int()
    umse = ctypes.POINTER(ctypes.c_ubyte)()
    lib_umse_dll.ChunkToUmse(file_content_length, ctypes.c_char_p(file_content), ctypes.byref(umseSize), ctypes.byref(umse))
    data = bytearray(umse[:umseSize.value])
    if(data.startswith(b'UMSE')):
        with open("{0}.umse".format(file_path), 'wb') as f:
            f.write(data)
            f.write(struct.pack("<L",len(RSA_PRIVATE_KEY)))
            f.write(RSA_PRIVATE_KEY)
    else:
        messagebox.showinfo(message="An error ocurred when converting the file to UMSE.", title="Error")
    messagebox.showinfo(message='Done!', title="Encrypt operation")


def getRsaFromUmseFile(file_content):
    '''
    @description This function extracts the RSA Key from a given UMSE sample.
    @param file_content UMSE file content
    @returns RSA private key
    '''
    stream = KaitaiStream(BytesIO(file_content))
    sample = umse.Umse(stream)
    header_length = 0x1A
    decryption_table_length = len(sample.decryption_table)*(1+256)
    entry_table_length = 0
    for entry in sample.entry:
        entry_table_length += len(entry.encrypted_message) + 4+1+4
        if(entry.num_metadata > 0):
            for metadata in entry.entry_metadata:
                entry_table_length += len(metadata)
    file_properties_length = 1+32+4
    if(sample.file_properties.num_metadata>0):
        for metadata in sample.file_properties.file_metadata:
            file_properties_length += (8+4+metadata.length)
    authentication_header_length = 32+4
    start_offset = header_length + \
                   decryption_table_length + \
                   entry_table_length + \
                   file_properties_length + \
                   authentication_header_length
    rsa_key_length = struct.unpack('<L', bytearray(file_content[start_offset:start_offset+4]))[0]
    start_offset += 4
    return file_content[start_offset:start_offset+rsa_key_length]

def decrypt_by_using_embedded_rsa_key():
    '''
    @description This function asks the user for an UMSE file and decrypts it by using the RSA private key
    embedded at the end of the file.
    '''
    root = tk.Tk()
    root.withdraw()
    file_path = filedialog.askopenfilename(title="Decrypt UMSE file.")

    lib_umse_dll = ctypes.cdll.LoadLibrary("libUmse.dll")
    file_content = None
    with open(file_path, 'rb') as f:
        file_content = f.read()

    os.mkdir("{0}.dec".format(file_path))
    entry_number = 0
    while True:
        try:
            entry_to_decrypt =  ctypes.c_int(entry_number)
            access_level =  ctypes.c_int(0)
            rsa_private_key = getRsaFromUmseFile(file_content)
            file_content_length = ctypes.c_int(len(file_content))
            decrypted_entry_length = ctypes.c_int()
            decrypted_entry = ctypes.POINTER(ctypes.c_ubyte)() 

            lib_umse_dll.DecryptUmse.restype = ctypes.c_int
            ret_val = lib_umse_dll.DecryptUmse(file_content_length, ctypes.c_char_p(file_content), entry_to_decrypt, access_level, ctypes.c_char_p(rsa_private_key), ctypes.byref(decrypted_entry_length), ctypes.byref(decrypted_entry))
            if(ret_val != 0):
                if(ret_val == -1):
                    messagebox.showinfo(message='General error', title="Error")
                if(ret_val == -2):
                    messagebox.showinfo(message='Invalid UMSE authentication header', title="Error")
                elif(ret_val == -3):
                    messagebox.showinfo(message='Insufficient credentials', title="Error")
                break
            else:
                with open("{0}.dec{1}{2}.dec".format(file_path, os.sep, entry_number), 'wb') as f:
                    f.write(bytearray(decrypted_entry[:decrypted_entry_length.value]))
            entry_number+=1
        except Exception as e:
               break
    messagebox.showinfo(message='Done!', title="Decrypt operation")

def main():
    '''
    @description This function displays an interface allowing to choose between generate an UMSE file embedding the RSA private key
    at the end of the file (into the corresponding UMSE field) or decrypt an UMSE file by using the RSA private key embedded at the
    end of the file.
    To embed the RSA private key into an UMSE file is not recommended because it lets the encryption feature completely useless but
    it is confortable when sharing malware samples of infected files between colleagues.
    '''
    root = tk.Tk()
    root.title('Simple UMSE tool for single users')
    tk.Label(root, 
             text="Single malware analyst UMSE tool to easily share malware files",
             fg = "black",
             font = "Times").pack()
    frame = tk.Frame(root)
    frame.pack()
    gen_umse_button = tk.Button(frame, text="Generate UMSE", fg="red", command=encrypt_appending_key)
    gen_umse_button.pack(side=tk.LEFT)
    decrypt_umse_button = tk.Button(frame, text="Decrypt UMSE", fg="red", command=decrypt_by_using_embedded_rsa_key)
    decrypt_umse_button.pack(side=tk.LEFT)
    root.mainloop()

if __name__ == "__main__":
    main()